## 1주차 답안

### 미나

#### Q1. 스프링 컨테이너의 생성 과정에 대해 설명 
1. 스프링 컴테이너 생성 => new AnnotationConfigApplicationContext([설정파일명].class)
2. 설정 파일에 Bean 어노테이션을 모두 스프링 컨테이너에 Bean 으로 등록 
    <br>등록 방식: key(메서드 명) - value(return 값) 
    <br> *주의 빈 이름은 중복이되면 안됨!
3. 스프링 빈 의존관계 설정
<br>

#### Q2. BeanFactory와 ApplicationContext에 대해 설명
BeanFactory는 스프링 컨테이너의 최상위 인터페이스로 스프링 빈을 관리 및 조회하는 역할을 담당한다.
ApplicationContext는 BeanFactory 를 상속받아 사용하며 BeanFactory가 수행하는 기능 외에 여러 부가 기능을 포함하므로
ApplicationContext를 주로 사용한다.

#### Q3. 싱글톤 패턴과 싱글톤 컨테이너의 차이점
직접 코드로 싱글톤패턴을 구현하는 경우 여러 문제점이 발생하는데, 
싱글톤 컨테이너의 경우 싱글톤 원칙은 지키면서 싱글톤 패턴에서 발생하는 여러 문제점을 해결해준다.

<싱글톤 패턴의 문제점>
<br>- 구현코드가 적지 않음.
<br>- 클라이언트가 구체 클래스에 의존하며 DIP원칙과 OCP원칙을 위반한다.
<br>- Test하기 쉽지 않다.
<br>- 내부 속성을 변경하거나 초기화 하기 어렵고 private생성자로 선언하여 자식 클래스를 만들기 어려운등 코드의 유연성이 떨어진다.


### 희준

#### Q1. SOLID 원칙 정리하기
- SRP(Single Responsibility Principle) 단일 책임 원칙
<br> 한 클래스는 하나의 책임만 가진다 (=> 판단 기준은 변경사항 발생시 파급효과가 아느정도인가!)
- OCP(Open/Closed Principle) 개방-폐쇄 원칙
<br> 확장에는 열려있고 변경에는 닫혀 있어야 한다.
<br> 다형성 개념에서 역할을 담당하는 구현(배역)을 변경하는 경우 직접적인 구현 코드를 수정하지 않고 기능을 변경할 수 있어야 한다.
  (=객체 구현 코드와 별개로 역할과 구현을 연결지어주는 설정자가 필요하다!)
- LSP(Liskov Subsitution Principle) 리스코프 치환 원칙
<br> 상위객체와 이를 상속받는 하위 객체가 존재하는 경우 하위 객체는 상위객체를 완전 대체할 수 있어야 한다.
  (= 하위 클래스는 인터페이스 규약을 모두 준수해야 한다)
- ISP(Interface Segregation Principle) 인터페이스 분리 원칙
<br>클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 으로 
큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있도록 한다
- DIP(Dependency Inversion Principle) 의존관계 역전 원칙
<br>의존 관계형성시 인터페이스(=역할)에 의존해야하며 구현클래스(=변경 될 수 있음)에 의존해선 안된다.
#### Q2.아래의 싱글톤 패턴 생성코드에서 static 으로 선언하는 이유
static이란? 
<br>객체마다 값이 달라지지 않는 공용으로 사용할 필드에 적용한다.
<br>메소드 영역의 클래스에 고정적으로 위치하는 맴버로 객체 생성없이 클래스를 통해 바로 접근이 가능하다.

싱글톤 패턴이란?
<br>싱글톤 패턴이란 클래스의 인스턴스가 하나만 생성되도록 만들어 하나의 인스턴스를 여러 클라이언트가 공유하며 사용하도록 하는 패턴

static 메서드에 대해서는 추가적으로 공부하기


#### Q3. 의존관계 주입방법 4가지와 이중 생성자주입방식이 권장되는 이유
- 생성자 주입 
<br> 생성자 호출시점에 1번만 호출되며 불변및필수(final) 의존관계에 사용된다
- 수정자(setter) 주입
<br> 생성자 주입과 달리 가변적인경우 사용한다.
- 필드 주입
<br> 클래스 맴버필드에 @Autowired를 사용해 바로 주입하는 방법이다
<br> 생성자 주입이나 수정자 주입과 같이 특정 상황(가변, 불변)인지 알수 없으며 
DI컨테이너 안에서만 작동하므로 순수 자바코드에서는 테스트가 불가능하다
- 일반 메서드 주입

### 정우
#### Q1. 객체지향의 5원칙 중 OCP에 대해 설명
위의 내용 참조 (희준-Q1)
#### Q2. 싱글톤 방식을 사용시 주의 할 점에 대해 설명
여러 클라이언트가 동일한 객체를 공유하므로 싱글톤 객체는 상태를 유지하지 않는 '무상태'로 설계해야한다.
(여기서 '무상태'란? 상태를 공유하는 필드 변수가 없는 것을 의미한다)
#### Q3. 의존 관계 주입 방법 네가지에 대해 설명
위의 내용 참조 (희준-Q3)

### 민욱
#### Q1. DI 컨테이너를 통해, 기존 자바 코드에 어떠한 문제를 해결할 수 있는지 설명 
다형성의 개념을 적용하며 SOLID(특히 OCP,DIP) 원칙을 준수하며 설계하기 위해서는 
interface(역할)과 구현체를 연결짓는 설정자가 필요한데 이 설정자를 DI컨테이너라 칭한다.
DI컨테이너를 사용하지 않는경우, 기능(=구현체변경)변경이 발생할 경우 구현 코드를 직접 수정해야 하므로 OCP,DIP원칙에 위배된다
 
#### Q2. @Autowired의 역할은 @Bean과 무슨 차이가 있는지에 대해 설명
컴포넌트 스캔을 사용하면 @Component 어노테이션이 붙은 클래스를 스캔해 스프링 빈으로 자동 등록을 해주며 
의존관계에 대한 설정정보를 입력하지 않기때문에 자동으로 주입될 수 있도록 @Autowired를 사용해야한다.


#### Q3. 빈 생명주기 콜백 시, @PostConstruct, @PreDestroy가 권장되는 이유에 대해 다른 방법과 비교하며 설명
빈 생명주기 콜백 방식은 크게 인터페이스, 설정정보 메서드, 어노테이션 방식이있다. 

인터페이스 (InitializingBean, DisposableBean) 방법은 스프링 전용 인터페이스이며
작성자가 코드를 고칠 수 없는 외부 라이브러리에 적용이 불가하며, 메서드의 이름을 변경할 수 없다.

설정정보에 메서드를 통해 지정하는 방식은 다음과 같다. 
<br>Bean(initMethod = "init", destroyMethod = "close")
<br>이 방식은 메서드 이름을 자유롭게 지정할 수 있으며, 스프링 코드에 의존하지 않는다. 
또한 설정정보이므로 코드 수정이 불가능한 외부 라이브러리에도 적용이 가능하다.

@postContruct, @PreDestroy 어노테이션 방식은
<br>추가 코드 없이 어노테이션 하나만 붙이면 되므로 가장 편리한 방식이다. 
단, 외부 라이브러리에는 적용이 불가능 하므로, 외부 라이브러리에 적용이 필요한 경우는 메서드 방식을 권장한다.
